package main

// heavily influenced from the go fix tool

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

var (
	fset = token.NewFileSet()
)

const (
	parserMode = parser.ParseComments
	debug      = false
)

var oldPath = flag.String("old-import", "",
	"the old import to be replaced")

var newPath = flag.String("new-import", "",
	"what to replace with old import with")

var regex = flag.Bool("regex", false,
	"paths are regular expressions")

func usage() {
	fmt.Fprintf(os.Stderr,
		"usage: fiximports -new-import [import name] -old-import [import to replace] [path ...]\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func main() {
	flag.Usage = usage
	flag.Parse()

	if *oldPath == "" || *newPath == "" {
		usage()
		os.Exit(1)
	}

	if flag.NArg() == 0 {
		if err := processFile("standard input", true, *regex); err != nil {
			reportAndExit(err)
		}
		os.Exit(1)
	}

	for i := 0; i < flag.NArg(); i++ {
		path := flag.Arg(i)
		switch dir, err := os.Stat(path); {
		case err != nil:
			reportAndExit(err)
		case dir.IsDir():
			walkDir(path)
		default:
			if err := processFile(path, false, *regex); err != nil {
				reportAndExit(err)
			}
		}
	}

	os.Exit(0)
}

func walkDir(path string) {
	filepath.Walk(path, visitFile)
}

func visitFile(path string, f os.FileInfo, err error) error {
	if err == nil && isGoFile(f) {
		err = processFile(path, false, *regex)
	}
	if err != nil {
		reportAndExit(err)
	}
	return nil
}

func isGoFile(f os.FileInfo) bool {
	// ignore non-Go files
	name := f.Name()
	return !f.IsDir() && !strings.HasPrefix(name, ".") && strings.HasSuffix(name, ".go")
}

func reportAndExit(err error) {
	fmt.Fprintf(os.Stderr, "Error: %v", err)
	os.Exit(1)
}

// imports reports whether f imports path.
func imports(f *ast.File, path string) bool {
	return importSpec(f, path) != nil
}

// importSpec returns the import spec if f imports path,
// or nil otherwise.
func importSpec(f *ast.File, path string) *ast.ImportSpec {
	for _, s := range f.Imports {
		if importPath(s) == path {
			return s
		}
	}
	return nil
}

func processFile(filename string, useStdin, regex bool) error {
	var f *os.File
	var err error

	if useStdin {
		f = os.Stdin
	} else {
		f, err = os.Open(filename)
		if err != nil {
			return err
		}
		defer f.Close()
	}

	src, err := ioutil.ReadAll(f)
	if err != nil {
		return err
	}

	file, err := parser.ParseFile(fset, filename, src, parserMode)
	if err != nil {
		return err
	}

	newFile := file

	fixed := rewriteImport(newFile, *oldPath, *newPath, regex)
	// AST changed.
	// Print and parse, to update any missing scoping
	// or position information for subsequent fixers.
	newSrc, err := gofmtFile(newFile)
	if err != nil {
		return err
	}
	newFile, err = parser.ParseFile(fset, filename, newSrc, parserMode)
	if err != nil {
		return err
	}

	if !fixed {
		return nil
	}
	fmt.Fprintf(os.Stderr, "fixed %s\n", filename)

	// Print AST.  We did that after each fix, so this appears
	// redundant, but it is necessary to generate gofmt-compatible
	// source code in a few cases. The official gofmt style is the
	// output of the printer run on a standard AST generated by the parser,
	// but the source we generated inside the loop above is the
	// output of the printer run on a mangled AST generated by a fixer.
	newSrc, err = gofmtFile(newFile)
	if err != nil {
		return err
	}

	if useStdin {
		os.Stdout.Write(newSrc)
		return nil
	}

	return ioutil.WriteFile(f.Name(), newSrc, 0)
}

func gofmtFile(f *ast.File) ([]byte, error) {
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, f); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// importPath returns the unquoted import path of s,
// or "" if the path is not properly quoted.
func importPath(s *ast.ImportSpec) string {
	t, err := strconv.Unquote(s.Path.Value)
	if err == nil {
		return t
	}
	return ""
}

// rewriteImport rewrites any import of path oldPath to path newPath.
func rewriteImport(f *ast.File, oldPath, newPath string, regex bool) (rewrote bool) {
	for _, cl := range f.Comments {
		if cl.List != nil {
			for _, c := range cl.List {
				if strings.HasPrefix(c.Text, "// import ") {
					rewrote = true
					re, err := regexp.Compile(oldPath)
					if err != nil {
						fmt.Printf("Error parsing oldPath as regex: %v", err)
						os.Exit(1)
					}
					if re.Match([]byte(c.Text)) {
						rewrote = true
						newStr := re.ReplaceAllString(c.Text, newPath)
						c.Text = newStr
					}
				}
			}
		}
	}
	for _, imp := range f.Imports {
		if regex {
			re, err := regexp.Compile(oldPath)
			if err != nil {
				fmt.Printf("Error parsing oldPath as regex: %v", err)
				os.Exit(1)
			}
			if re.Match([]byte(imp.Path.Value)) {
				rewrote = true
				newStr := re.ReplaceAllString(imp.Path.Value, newPath)
				imp.Path.Value = newStr
			}
		} else {
			if importPath(imp) == oldPath {
				rewrote = true
				// record old End, because the default is to compute
				// it using the length of imp.Path.Value.
				imp.EndPos = imp.End()
				imp.Path.Value = strconv.Quote(newPath)
			}
		}
	}
	return
}
